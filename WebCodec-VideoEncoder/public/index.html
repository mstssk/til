<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebCodec VideoEncoder</title>

  <script src="./index.js"></script>
</head>

<body>

  <h1>WebCodec VideoEncoder</h1>

  <button id="start">Start</button>
  <button id="stop">Stop</button>
  <button id="download">Download</button>
  <br>
  <br>
  <!-- <video id="video" autoplay controls></video> -->

  <script type="module">
    import { Muxer, ArrayBufferTarget } from "https://www.unpkg.com/webm-muxer@4.0.1/build/webm-muxer.mjs";

    // const video = document.getElementById('video');
    const start = document.getElementById('start');
    const stop = document.getElementById('stop');
    const download = document.getElementById('download');

    start.addEventListener('click', async () => {
      const muxer = new Muxer({
        target: new ArrayBufferTarget(),
        video: {
          codec: 'V_VP9',
          width: 1280,
          height: 720
        }
      });

      const stream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
        // audio: true
      });
      // video.width = 1280;
      // video.height = 720;
      // video.srcObject = stream;

      const processor = new MediaStreamTrackProcessor({ track: stream.getVideoTracks()[0] });
      const reader = processor.readable.getReader();

      const encoder = new VideoEncoder({
        output: (chunk, metadata) => {
          muxer.addVideoChunk(chunk, metadata)
          console.log(chunk);
          if (metadata.decoderconfig) {
            console.log(metadata.decoderconfig);
          }
        },
        error: (e) => console.error(e.message)
      });
      encoder.configure({
        codec: "vp09.00.10.08",
        hardwareAcceleration: "prefer-software",
        width: 1280,
        height: 720,
        framerate: 30
      });

      let reqId;
      let frame_counter = 0;
      const func = async () => {
        const result = await reader.read();
        if (result.done) {
          cancelAnimationFrame(reqId);
          console.log('done', result);
          return;
        };
        console.log('requestAnimationFrame');

        let frame = result.value;
        if (encoder.encodeQueueSize > 2) {
          // Too many frames in flight, encoder is overwhelmed
          // let's drop this frame.
          frame.close();
          console.log('dropped frame');
        } else {
          frame_counter++;
          const insert_keyframe = frame_counter % 150 === 0;
          encoder.encode(frame, { keyFrame: insert_keyframe });
          frame.close();
        }
        reqId = requestAnimationFrame(func);
      };
      reqId = requestAnimationFrame(func);

      stream.getVideoTracks().forEach(track => {
        track.onended = async () => {
          cancelAnimationFrame(reqId);

          await encoder.flush();
          muxer.finalize();

          const blob = new Blob([muxer.target.buffer], { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.setAttribute('href', url);
          a.setAttribute('download', 'video.webm');
          a.click();
          URL.revokeObjectURL(url);

        };
      });

    });

    stop.addEventListener('click', () => {
      alert("noop");
    });
  </script>

</body>

</html>
