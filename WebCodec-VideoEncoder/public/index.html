<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebCodec VideoEncoder</title>

  <script src="./index.js"></script>
</head>

<body>

  <h1>WebCodec VideoEncoder</h1>

  <button id="start">Start</button>
  <button id="stop">Stop</button>
  <button id="download">Download</button>
  <br>
  <br>
  <!-- <video id="video" autoplay controls></video> -->

  <script type="module">
    import { Muxer, ArrayBufferTarget } from "https://www.unpkg.com/webm-muxer@4.0.1/build/webm-muxer.mjs";

    // const video = document.getElementById('video');
    const start = document.getElementById('start');
    const stop = document.getElementById('stop');
    const download = document.getElementById('download');

    start.addEventListener('click', async () => {
      const muxer = new Muxer({
        target: new ArrayBufferTarget(),
        video: {
          codec: 'V_VP9',
          width: 1280,
          height: 720
        }
      });

      const stream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
        // audio: true
      });
      // video.width = 1280;
      // video.height = 720;
      // video.srcObject = stream;

      const processor = new MediaStreamTrackProcessor({ track: stream.getVideoTracks()[0] });
      const reader = processor.readable.getReader();

      const encoder = new VideoEncoder({
        output: (chunk, metadata) => {
          muxer.addVideoChunk(chunk, metadata)
          console.log(chunk);
          if (metadata.decoderconfig) {
            console.log(metadata.decoderconfig);
          }
        },
        error: (e) => console.error(e.message)
      });
      encoder.configure({
        codec: "vp09.00.10.08",
        hardwareAcceleration: "prefer-software",
        // ストリームの実際の解像度とフレームレートを指定する場合、ストリームを一度Video要素に書き出す必要があり面倒。
        width: 1920,
        height: 1080,
        framerate: 30,
        bitrate: 6 * 1000 * 1000, // 6Mbps
      });

      stream.getVideoTracks().forEach(track => {
        track.onended = async () => {

          await encoder.flush();
          muxer.finalize();

          const blob = new Blob([muxer.target.buffer], { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.setAttribute('href', url);
          a.setAttribute('download', 'video.webm');
          a.click();
          URL.revokeObjectURL(url);

        };
      });

      // requestAnimationFrameだとタブが非アクティブの時に処理が止まるので、whileループで代用
      let frame_counter = 0;
      (async () => {
        while (true) {
          const result = await reader.read();
          if (result.done) {
            console.log('done', result);
            break;
          };
          console.log('requestAnimationFrame');

          let frame = result.value;
          if (encoder.encodeQueueSize > 2) {
            // Too many frames in flight, encoder is overwhelmed
            // let's drop this frame.
            frame.close();
            console.log('dropped frame');
          } else {
            frame_counter++;
            const insert_keyframe = frame_counter % 150 === 0;
            console.log('encode', frame_counter, insert_keyframe);
            encoder.encode(frame, { keyFrame: insert_keyframe });
            frame.close();
          }
        }
      })();

    });

    stop.addEventListener('click', () => {
      alert("noop");
    });
  </script>

</body>

</html>
