<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebCodec VideoEncoder</title>
</head>

<body>

  <h1>WebCodec VideoEncoder</h1>

  <button id="start">Start Recoding</button><br>
  <br>
  <label><input type="checkbox" id="use_canvas">Use Canvas</label>

  <!-- <video id="video" autoplay controls></video> -->

  <script type="module">
    import { Muxer, ArrayBufferTarget } from "https://www.unpkg.com/webm-muxer@4.0.1/build/webm-muxer.mjs";

    const start = document.getElementById('start');

    start.addEventListener('click', async () => {
      const displayStream = await navigator.mediaDevices.getDisplayMedia({
        video: {
          width: { max: 1920 },
          height: { max: 1080 },
        },
      });

      const videoElem = await new Promise((resolve) => {
        const videoElem = document.createElement('video');
        videoElem.preload = 'auto';
        videoElem.muted = true;
        videoElem.onloadedmetadata = (e) => {
          videoElem.onloadedmetadata = null;
          resolve(videoElem);
        };
        videoElem.srcObject = displayStream;
        videoElem.play();
      });
      const width = videoElem.videoWidth;
      const height = videoElem.videoHeight;
      console.log({ width, height });

      let captureStream;
      if (use_canvas.checked) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const intervalId = setInterval(() => {
          canvas.getContext('2d').drawImage(videoElem, 0, 0, width, height);
        }, Math.floor(1000 / 30));
        captureStream = canvas.captureStream(30);
        displayStream.getVideoTracks().forEach(track => {
          track.addEventListener("ended", () => {
            clearInterval(intervalId);
          });
        });
      } else {
        captureStream = displayStream;
      }

      const videoReader = new MediaStreamTrackProcessor({ track: captureStream.getVideoTracks()[0] }).readable.getReader();

      const muxer = new Muxer({
        target: new ArrayBufferTarget(),
        video: {
          codec: 'V_VP9',
          width: width,
          height: height,
          frameRate: 30,
        },
        firstTimestampBehavior: 'offset',
        streaming: true,
      });

      let start;
      const videoEncoder = new VideoEncoder({
        output: (chunk, metadata) => {
          if (!start) {
            start = new Date();
          }
          // console.log(videoEncoder.state);
          console.log(chunk);
          if (metadata.decoderconfig) {
            console.log("decoderconfig", metadata.decoderconfig);
          }
          muxer.addVideoChunk(chunk, metadata)
        },
        error: (e) => console.error(e.message)
      });
      videoEncoder.configure({
        codec: "vp09.00.10.08",
        hardwareAcceleration: "prefer-software",
        // ストリームの実際の解像度とフレームレートを指定する場合、ストリームを一度Video要素に書き出す必要があり面倒。
        width: width,
        height: height,
        framerate: 30,
        bitrate: 6 * 1000 * 1000, // 6Mbps
      });

      displayStream.getVideoTracks().forEach(track => {
        track.onended = async () => {

          await videoEncoder.flush();
          videoEncoder.close();
          muxer.finalize();
          console.log("Recorded duration", (new Date() - start) / 1000);

          const blob = new Blob([muxer.target.buffer], { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.setAttribute('href', url);
          a.setAttribute('download', 'video.webm');
          a.click();
          URL.revokeObjectURL(url);

        };
      });

      // requestAnimationFrameだとタブが非アクティブの時に処理が止まるので、whileループで代用
      let frame_counter = 0;
      let lastKeyDate = start;
      (async () => {
        while (true) {
          const result = await videoReader.read();
          if (result.done) {
            console.log('done', result);
            break;
          };

          let frame = result.value;
          if (videoEncoder.encodeQueueSize > 2) {
            // Too many frames in flight, encoder is overwhelmed
            // let's drop this frame.
            console.warn('dropped frame');
          } else {
            frame_counter++;
            // WebMの制限で32768ms以上のdurationを持つフレームは分割しないといけない。
            const passed30secs = (new Date() - lastKeyDate) / 1000 > 30;
            const insert_keyframe = frame_counter % 150 === 0 || passed30secs;
            if (insert_keyframe) {
              lastKeyDate = new Date();
            }
            console.log('encode', frame_counter, insert_keyframe);
            videoEncoder.encode(frame, { keyFrame: insert_keyframe });
          }
          frame.close();
        }
      })();
    });

  </script>

</body>

</html>
